<?php

/**
 * Implementation of hook_menu();
 */
function taxonomy_menu_block_menu() {
  $items = array();
  // our page where we list our existing blocks
  $items['admin/config/development/taxonomy_menu_block'] = array(
      'title' => 'Taxonomy menu block',
      'description' => 'Displays taxonomies as blocks',
      'page callback' => 'taxonomy_menu_block_list',
      'type' => MENU_NORMAL_ITEM,
      'access arguments' => array('administer taxonomy menu block'),
      'file' => 'taxonomy_menu_block.settings.inc',
  );
  // page where we add new blocks
  $items['admin/config/development/taxonomy_menu_block/add'] = array(
      'title' => 'Add a taxonomy menu block',
      'page callback' => 'drupal_get_form',
      'page arguments' => array('taxonomy_menu_block_form'),
      'type' => MENU_CALLBACK,
      'access arguments' => array('administer taxonomy menu block'),
      'file' => 'taxonomy_menu_block.settings.inc',
  );
  // page where we edit blocks
  $items['admin/config/development/taxonomy_menu_block/edit/%'] = array(
      'title' => 'Edit a taxonomy menu block',
      'page callback' => 'taxonomy_menu_block_form_edit',
      'page arguments' => array(5),
      'type' => MENU_CALLBACK,
      'access arguments' => array('administer taxonomy menu block'),
      'file' => 'taxonomy_menu_block.settings.inc',
  );
  // page where we clone blocks
  $items['admin/config/development/taxonomy_menu_block/clone/%'] = array(
      'title' => 'Clone a taxonomy menu block',
      'page callback' => 'taxonomy_menu_block_form_clone',
      'page arguments' => array(5),
      'type' => MENU_CALLBACK,
      'access arguments' => array('administer taxonomy menu block'),
      'file' => 'taxonomy_menu_block.settings.inc',
  );
  // page where we delete blocks
  $items['admin/config/development/taxonomy_menu_block/delete/%'] = array(
      'title' => 'Delete a taxonomy menu block',
      'page callback' => 'drupal_get_form',
      'page arguments' => array('taxonomy_menu_block_form_delete'),
      'type' => MENU_CALLBACK,
      'access arguments' => array('administer taxonomy menu block'),
      'file' => 'taxonomy_menu_block.settings.inc',
  );
  return $items;
}

/**
 * Validation function for our taxonomy_menu_block_form form
 */
function taxonomy_menu_block_form_validate($form, &$form_state) {
  // check if we have valid values
  if ($form_state['values']['depth'] == '0' || (!empty($form_state['values']['depth']) && !ctype_digit($form_state['values']['depth'])))
    form_set_error('depth', t('Depth must be a positive numeric value'));
  if ($form_state['values']['level_as_text'] == '0' || (!empty($form_state['values']['level_as_text']) && !ctype_digit($form_state['values']['level_as_text'])))
    form_set_error('level_as_text', t('Text level must be a positive numeric value'));

  // check if our starting level is valid
  if ($form_state['values']['starting_level'] == '0' || (!empty($form_state['values']['starting_level']) && !ctype_digit($form_state['values']['starting_level']))) {
    form_set_error('starting_level', t('Starting level must be a positive numeric value'));
  } else {
    // check how deep our tree goes, user cannot enter a value higher than this
    global $language;
    $lang = $language->language;
    $tree = taxonomy_menu_block_get_tree($form_state['values']['vid'], $lang);
    $total_depth = 0;
    foreach ($tree as $term) {
      if ($term->depth > $total_depth)
        $total_depth = $term->depth;
    }
    if ($form_state['values']['starting_level'] > $total_depth)
      form_set_error('starting_level', t('Your starting level cannot be deeper than the maximum depth of your taxonomy'));
  }

  // check if depth is higher than starting level
  if (!empty($form_state['values']['depth']) && ($form_state['values']['depth'] < $form_state['values']['starting_level']))
    form_set_error('depth', t('Depth must always be higher than starting level'));

  // check css classes field
  if (!empty($form_state['values']['extra_classes'])) {
    $allowed = "#[^a-z0-9\s-_]#i";
    preg_match($allowed, $form_state['values']['extra_classes'], $matches);
    if (!empty($matches))
      form_set_error('extra_classes', t('Extra CSS classes can only contain letters, numbers, underscores and spaces'));
  }
}

/**
 * Submit function for our taxonomy_menu_block_form form
 */
function taxonomy_menu_block_form_submit($form, &$form_state) {
  // add our block values to a new array
  $tmb['vid'] = $form_state['values']['vid'];
  $tmb['name'] = $form_state['values']['name'];
  $tmb['depth'] = !empty($form_state['values']['depth']) ? $form_state['values']['depth'] : NULL;
  // subtract 1 here and add it again later in the form.
  // drupal uses 0 as lowest value, we use 1 as lowest value to not confuse our user
  $tmb['level_as_text'] = !empty($form_state['values']['level_as_text']) ? $form_state['values']['level_as_text'] - 1 : NULL;
  $tmb['starting_level'] = !empty($form_state['values']['starting_level']) ? $form_state['values']['starting_level'] - 1 : NULL;
  $tmb['node_count'] = $form_state['values']['node_count'];
  $tmb['active_trail'] = $form_state['values']['active_trail'];
  $tmb['extra_classes'] = $form_state['values']['extra_classes'];

  // get our taxonomy_menu_block variable, which stores everything in a serialized nested array
  $tmb_array = variable_get('taxonomy_menu_block', $default = NULL);
  $tmb_array = unserialize($tmb_array);

  // if we have a NEW block
  if (empty($form_state['values']['delta'])) {
    // make a unique machine name
    // this can probably be done in a more efficient way
    $delta = preg_replace('/[^a-zA-Z0-9]/', '_', strtolower($form_state['values']['name']));
    if (!empty($tmb_array) && (array_key_exists($delta, $tmb_array)))
      $delta = $delta . '_';
    $tmb_array[$delta] = $tmb;
    $msg = t('New taxonomy menu block <i>' . $tmb['name'] . '</i> added');
  }
  // if we have an EXISTING block that needs to be edited
  else {
    $tmb_array[$form_state['values']['delta']] = $tmb;
    $msg = t('Taxonomy menu block <i>' . $tmb['name'] . '</i> edited');
  }

  // save our taxonomy block variable
  $tmb_array = serialize($tmb_array);
  variable_set('taxonomy_menu_block', $tmb_array);

  $form_state['redirect'] = 'admin/config/development/taxonomy_menu_block';

  drupal_get_messages(); // reset other possible messages that might still be displayed
  drupal_set_message($msg, 'status');
}

/**
 * Submit function for our taxonomy_menu_block_form_delete form
 */
function taxonomy_menu_block_form_delete_submit($form, &$form_state) {
  $tmb_array = variable_get('taxonomy_menu_block', $default = NULL);
  $tmb_array = unserialize($tmb_array);

  // remember the name for confirmation msg
  $tmb = $tmb_array[$form_state['values']['delta']]['name'];

  unset($tmb_array[$form_state['values']['delta']]);

  $tmb_array = serialize($tmb_array);
  variable_set('taxonomy_menu_block', $tmb_array);

  $form_state['redirect'] = 'admin/config/development/taxonomy_menu_block';
  drupal_set_message(t('Taxonomy menu block <i>' . $tmb . '</i> deleted'), 'status');
}

/**
 * Implementation of hook_block_info();
 */
function taxonomy_menu_block_block_info() {
  // get all our current blocks
  $tmb_array = variable_get('taxonomy_menu_block', $default = NULL);
  $tmb_array = unserialize($tmb_array);

  if (!empty($tmb_array)) {
    foreach ($tmb_array as $tmb_delta => $tmb) {
      $blocks[$tmb_delta] = array(
          'info' => t('Taxonomy menu block - ' . $tmb['name']),
          'cache' => DRUPAL_NO_CACHE,
      );
    }
    return $blocks;
  }
}

/**
 * Implementation of hook_block_view();
 */
function taxonomy_menu_block_block_view($delta = '') {
  // get all our current blocks
  $tmb_array = variable_get('taxonomy_menu_block', $default = NULL);
  $tmb_array = unserialize($tmb_array);

  if (!empty($tmb_array)) {
    foreach ($tmb_array as $tmb_delta => $tmb) {
      if ($delta == $tmb_delta) {
        $block = array();
        $block['subject'] = $tmb['name'];

        // get active trail, if needed
        if ($tmb['active_trail'] == '1')
          $active_trail = taxonomy_menu_block_find_active($tmb['vid']);
        else
          $active_trail = NULL;

        // build tree
        $tree = taxonomy_menu_block_build_taxonomy_tree($tmb['vid'], $tmb['depth'], $tmb['starting_level']);
        $items = taxonomy_menu_block_generate_menu($tree, $tmb, $active_trail);

        $content = theme('taxonomy_menu_block', array('items' => $items));
        $block['content'] = $content;

        return $block;
      }
    }
  }
}

/*
 * function to generate markup for our list
 */

function theme_taxonomy_menu_block($variables) {
  $items = $variables['items'];
  $output = '<ul class="tmb">';
  foreach ($items as $item) {
    $output .= '<li';
    // add the classes to the li
    if (isset($item['class'])) {
      $output .= ' class="' . implode(' ', $item['class']) . '"';
    }
    $output .= '>';
    $output .= $item['data'];
    if (isset($item['children'])) {
      //$variables['items'] = $item['children'];
      $output .= theme_taxonomy_menu_block(array('items' => $item['children']));
    }
    $output .= '</li>';
  }
  $output .= '</ul>';
  return $output;
}

/**
 * Build our nested array that we will use to pass on to Drupal's theme_list_item function
 * This is where we set all our options 
 * @param type $tree
 * @param type $active_trail
 * @param type $node_count
 * @param type $level_as_text
 * @return type 
 */
function taxonomy_menu_block_generate_menu($tree, $tmb, $active_trail = NULL) {

  foreach ($tree as $tid => $term) {
    $item = array();

    // add css classes
    $item['class'][] = 'level-' . ($term->depth + 1);
    if (isset($active_trail) && in_array($tid, $active_trail))
      $item['class'][] = 'active-trail';
    if (isset($active_trail) && $tid == $active_trail[0])
      $item['class'][] = 'active';
    if (!empty($tmb['extra_classes'])) {
      $classes = explode(' ', $tmb['extra_classes']);
      $item['class'] = array_merge($item['class'], $classes);
    }

    $title = $term->name;
    if ($tmb['node_count'] == 1) {
      $title .= t(' (@count)', array('@count' => taxonomy_menu_block_count_nodes_term($term->tid)));
    }

    if ($tmb['level_as_text'] == '' || ($tmb['level_as_text'] != '' && $tmb['level_as_text'] != $term->depth)) {
      $item['data'] = l($title, 'taxonomy/term/' . $term->tid);
    }
    else
      $item['data'] = $title;

    if (isset($term->children)) {
      $item['children'] = taxonomy_menu_block_generate_menu($term->children, $tmb, $active_trail);
    }

    $items[] = $item;
  }

  return $items;
}

/*
 * Implementation of hook_theme
 */

function taxonomy_menu_block_theme() {
  return array(
      'taxonomy_menu_block' => array(
          //'template' => 'taxonomy_menu_block',
          'variables' => array('items' => NULL),
      ),
  );
}

/**
 * Generates & returns a nested array of taxonomy terms for the specified vocabulary id;
 * @return 
 * @param object $vid
 * @param object $parent[optional]
 * @param object $max_depth[optional]
 */
function taxonomy_menu_block_build_taxonomy_tree($vid, $depth = NULL, $starting_level = NULL) {

  $terms = array();
  global $language;
  $lang = $language->language;
  $data = taxonomy_menu_block_get_tree($vid, $lang, 0, $depth);
  foreach ($data as $term) {
    if ($term->depth >= $starting_level)
      $terms[$term->tid] = $term;
  }
  $terms = taxonomy_menu_block_nest_taxonomy_terms($terms);

  return $terms;
}

/**
 * Function to generate our taxonomy tree, taking into account i18n
 * @param type $vid
 * @param string $lang
 * @param type $parent
 * @return type 
 */
function taxonomy_menu_block_get_tree($vid, $lang, $parent = 0, $depth = NULL) {
  if (module_exists('i18n_taxonomy')) {
    $data = i18n_taxonomy_get_tree($vid, $lang, $parent, $depth);
    if ((isset($data)) && (count($data) == 0)) {
      $lang = 'und';
      $data = i18n_taxonomy_get_tree($vid, $lang, $parent, $depth);
    }
  } else {
    $data = taxonomy_get_tree($vid, $parent, $depth);
  }
  return $data;
}

/**
 * Looks for each term's parent term in the given tree and assigns 
 * the child to the parent.
 * @return 
 * @param object $terms
 * @param object $parent
 */
function taxonomy_menu_block_nest_taxonomy_terms($terms) {

  foreach ($terms as $term) {
    $parent_tid = isset($term->parents[0]) ? $term->parents[0] : 0;

    // if terms have a parent id that is not 0 & is in the array
    if ($parent_tid && isset($terms[$parent_tid])) {
      $terms[$parent_tid]->children[$term->tid] = $term;
      // remember terms that get nested and that we must delete
      $to_delete[] = $term->tid;
    }
  }

  // loop through our to_delete terms
  if (isset($to_delete)) {
    foreach ($to_delete as $delete) {
      unset($terms[$delete]);
    }
  }

  return $terms;
}

/**
 * Counts the number of nodes assigned to a term.
 * @return integer $count - number of nodes
 * @param integer $tid - term id
 */
function taxonomy_menu_block_count_nodes_term($tid) {
  return db_select('taxonomy_index', 'ti')
                  ->condition('tid', (int) $tid)
                  ->countQuery()
                  ->execute()
                  ->fetchField();
}

/**
 * Function to find our active trail
 * @global type $language
 */
function taxonomy_menu_block_find_active($vid) {
  global $language;
  $lang = $language->language;
  $data = taxonomy_menu_block_get_tree($vid, $lang);

  // find active term
  foreach ($data as $key => $value) {
    $path = 'taxonomy/term/' . $value->tid;
    if (($path == $_GET['q'] || ($path == '<front>' && drupal_is_front_page())) && (empty($options['language']) || $options['language']->language == $language_url->language))
      $active = $value;
  }

  if (isset($active)) {
    // structure data array
    foreach ($data as $key => $value) {
      $data_new[$value->tid] = $value;
    }
    $active_trail = taxonomy_menu_block_get_trail($data_new, $active);
  } else {
    $active_trail = NULL;
  }

  return $active_trail;
}

/**
 * Function to find possible active items that are higher up in the tree
 * @param type $data
 * @param type $active
 * @return type 
 */
function taxonomy_menu_block_get_trail($data, $active) {
  $active_trail[] = $active->tid;
  $parent = $active->parents[0];
  for ($i = 0; $i < $active->depth; $i++) {
    $active_trail[] = $data[$parent]->tid;
    $parent = $data[$parent]->parents[0];
  }
  return $active_trail;
}