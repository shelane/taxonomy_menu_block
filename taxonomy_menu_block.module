<?php

/**
 * @file
 * This module allows you to make menu blocks out of your taxonomies in a very
 * performant way.
 */

// Off-load the following infrequently called hooks & functions to another file.
function taxonomy_menu_block_form_alter(&$form, &$form_state, $form_id) {
  module_load_include('inc', 'taxonomy_menu_block', 'taxonomy_menu_block.settings');
  return _taxonomy_menu_block_form_alter($form, $form_state, $form_id);
}

function taxonomy_menu_block_block_info() {
  module_load_include('inc', 'taxonomy_menu_block', 'taxonomy_menu_block.settings');
  return _taxonomy_menu_block_block_info();
}

function taxonomy_menu_block_edit_block($form, &$form_state) {
  module_load_include('inc', 'taxonomy_menu_block', 'taxonomy_menu_block.settings');
  return _taxonomy_menu_block_edit_block($form, $form_state);
}

function taxonomy_menu_block_clear_cache($form, &$form_state) {
  module_load_include('inc', 'taxonomy_menu_block', 'taxonomy_menu_block.settings');
  return _taxonomy_menu_block_clear_cache($form, $form_state);
}

/**
 * Implements hook_menu().
 */
function taxonomy_menu_block_menu() {
  // Add block form.
  $items['admin/structure/block/add-taxonomy-menu-block'] = array(
    'title' => 'Add taxonomy menu block',
    'description' => 'Add a new taxonomy menu block.',
    'page callback' => 'drupal_get_form',
    'page arguments' => array('taxonomy_menu_block_add_block_form'),
    'access arguments' => array('administer blocks'),
    'type' => MENU_LOCAL_ACTION,
    'file' => 'taxonomy_menu_block.settings.inc',
  );

  // Display "add taxonomy menu block" link on block overview page.
  $default_theme = variable_get('theme_default', 'bartik');
  foreach (list_themes() as $key => $theme) {
    if ($key != $default_theme) {
      $items['admin/structure/block/list/' . $key . '/add-taxonomy-menu-block'] = array(
        'title' => 'Add taxonomy menu block',
        'description' => 'Add a new taxonomy menu block.',
        'page callback' => 'drupal_get_form',
        'page arguments' => array('taxonomy_menu_block_add_block_form'),
        'access arguments' => array('administer blocks'),
        'type' => MENU_LOCAL_ACTION,
        'file' => 'taxonomy_menu_block.settings.inc',
      );
    }
  }

  // Delete block.
  $items['admin/structure/block/delete-taxonomy-menu-block'] = array(
    'title' => 'Delete taxonomy menu block',
    'page callback' => 'drupal_get_form',
    'page arguments' => array('taxonomy_menu_block_delete'),
    'access arguments' => array('administer blocks'),
    'type' => MENU_CALLBACK,
    'file' => 'taxonomy_menu_block.settings.inc',
  );

  return $items;
}

/**
 * Implements hook_theme().
 */
function taxonomy_menu_block_theme() {
  return array(
    'taxonomy_menu_block' => array(
      'variables' => array(
        'items' => NULL,
        'config' => NULL,
      ),
    ),
  );
}

/**
 * Implements hook_block_view().
 */
function taxonomy_menu_block_block_view($delta = '') {
  $config = taxonomy_menu_block_get_config($delta);
  $data = taxonomy_menu_block_build($config);
  return $data;
}

/**
 * Function to build our tree.
 *
 * @param array $config
 *   An array of configuration options that specifies how to build the
 *   taxonomy tree
 *   - admin_title: Administrative title to use on the block admin page
 *   - vid: Taxonomy vocabulary id
 *   - parent: What kind of tree we will build
 *       0: Display the whole tree
 *       1: Fixed parent: display only a branch of tree, parent is given
 *       2: Dynamic tree: will look at currently viewed page, find an active tid
 *          and display the children of that tid
 *   - parent_fixed: The fixed parent tid in case parent is set to 1
 *   - parent_dynamic: Determines at what depth we need to find the parent tid
 *     in case parent is set to 2
 *   - depth: Until what depth we need to render our tree.
 *
 * @return array
 *   Array that contains one value: content, which is the fully rendered HTML
 *   of our tree
 */
function taxonomy_menu_block_build($config) {

  $tree = array();
  $data['content'] = '';
  $parent = NULL;

  // Get tree.
  $tree = taxonomy_menu_block_get_tree($config['vid']);

  // Find active tid.
  $tid = taxonomy_menu_block_find_active_tid($tree, $config['vid']);

  // Let other modules alter the active tid.
  drupal_alter('taxonomy_menu_block_active_tid', $tid, $config);

  // If we have a dynamic parent and no active tid, bail out.
  if ($config['parent'] == '2' && !$tid) {
    return;
  }

  // Add the active trail.
  $tree = taxonomy_menu_block_add_active_trail($tree, $tid);

  // Set parent for fixed parent blocks.
  if ($config['parent'] == '1') {
    $parent = $config['parent_fixed'];
  }

  // If we have a dynamic parent, find the parent tid.
  if ($config['parent'] == '2') {
    if ($config['parent_dynamic'] != '0') {
      // Loop over tree and find the highest item in active trail, taking into
      // account our specified depth.
      foreach ($tree as $key => $term) {
        if ($term['active_trail'] != '0' && $term['depth'] == ($config['parent_dynamic'] - 1)) {
          $parent = $key;
        }
      }
    }
    else {
      $parent = $tid;
    }

    // Since we know we have an active tid, no parent can only mean
    // user didn't configure correctly.
    if (!$parent) {
      drupal_set_message(t('Parent level or depth configured incorrectly'), 'error');
      return;
    }
  }

  // Trim tree to one branch.
  if ($parent) {
    // Loop over tree, store all items that have higher depth than parent.
    // First item that has the same depth means new branch of tree.
    $start = FALSE;
    $branch = array();

    foreach ($tree as $key => $term) {
      // Stop storing once we hit a term with same depth as $parent.
      if ($term['depth'] <= $tree[$parent]['depth']) {
        $start = FALSE;
      }
      if ($start == TRUE) {
        $branch[$key] = $term;
      }
      // Only start storing from when we hit $parent.
      if ($key == $parent && $start != TRUE) {
        $start = TRUE;
      }
    }

    // An empty array means that we don't have any children for this branch.
    if ($branch) {
      $tree = $branch;
    }
    else {
      return;
    }
  }

  // Depth trim. Always do this last as to not lose the active trail.
  if ($config['depth'] != '0') {
    // Substract one of our max depth because Drupal considers 0 to be
    // the root level.
    $max_depth = $config['depth'] - 1;

    $temp_tree = array();
    foreach ($tree as $tid => $term) {
      if ($term['depth'] <= $max_depth) {
        $temp_tree[$tid] = $term;
      }
    }
    if ($temp_tree) {
      $tree = $temp_tree;
    }
    else {
      return;
    }
  }

  // Last check. If we for some reason still don't have a built tree, bail.
  if (empty($tree)) {
    return;
  }

  // Let other modules alter the taxonomy tree data.
  drupal_alter('taxonomy_menu_block_tree', $tree, $config);

  // Nest tree.
  // If we have a parent, pass along parent.
  if ($parent) {
    $tree = taxonomy_menu_block_nest_tree($tree, $parent);
  }
  else {
    $tree = taxonomy_menu_block_nest_tree($tree);
  }

  // Theme tree.
  $data['content'] = theme('taxonomy_menu_block', array('items' => $tree, 'config' => $config));

  return $data;
}

/**
 * Returns the configuration for the requested block delta.
 *
 * @param string $delta
 *   The delta that uniquely identifies the block in the block system. If
 *   not specified, the default configuration will be returned.
 *
 * @return array
 *   An associated array of configuration options.
 */
function taxonomy_menu_block_get_config($delta = NULL) {
  // Initialize.
  $config = array(
    'delta' => $delta,
    'admin_title' => '',
    'vid' => 1,
    'parent' => 0,
    'parent_fixed' => 0,
    'parent_dynamic' => 1,
    'depth' => 0,
  );

  // Get the block configuration options.
  if ($delta) {
    $taxonomy_menu_block = variable_get("taxonomy_menu_block_{$delta}", array());
    $config = unserialize($taxonomy_menu_block);
  }

  return $config;
}

/**
 * Generate taxonomy tree, taking into account i18n.
 */
function taxonomy_menu_block_get_tree($vid) {

  if (module_exists('i18n_taxonomy')) {
    global $language;
    $lang = $language->language;

    // Get cache. Format of cache id: module_name-vid-language.
    $cache = cache_get('taxonomy_menu_block-' . $vid . '-' . $lang);

    if ($cache) {
      $tree = $cache->data;
    }
    else {
      $data = i18n_taxonomy_get_tree($vid, $lang);

      // If data is empty, we have a vocabulary that is set to Translate or
      // Fixed but none of the terms are actually translated
      // (in the current language).
      // Or the vacobulary is set to localize.
      if (empty($data)) {
        $data = i18n_taxonomy_localize_terms(i18n_taxonomy_get_tree($vid, 'und'));
      }

      $tree = taxonomy_menu_block_structure_tree($data, $lang);
      $cache = cache_set('taxonomy_menu_block-' . $vid . '-' . $lang, $tree);
    }
  }
  else {
    $cache = cache_get('taxonomy_menu_block-' . $vid);
    if (!$cache) {
      $data = taxonomy_get_tree($vid);
      $tree = taxonomy_menu_block_structure_tree($data);
      $cache = cache_set('taxonomy_menu_block-' . $vid, $tree);
    }
    else {
      $tree = $cache->data;
    }
  }

  return $tree;
}

/**
 * Structure tree with only the info we need.
 */
function taxonomy_menu_block_structure_tree($data, $lang = NULL) {
  $tree = array();

  foreach ($data as $term) {
    // If one term in a localized taxonomy isn't translated all terms get
    // returned without a depth or a parent, giving us unusable results.
    // We leave those out here.
    if (isset($term->depth)) {
      $branch['name'] = $term->name;
      // Get path here as it requires an extra db query.
      // This way we get it in cache.
      $branch['path'] = drupal_get_path_alias('taxonomy/term/' . $term->tid, $lang);
      $branch['depth'] = $term->depth;
      $branch['parents'] = $term->parents;
      $branch['active_trail'] = '0';
      $tree[$term->tid] = $branch;
    }
  }

  return $tree;
}

/**
 * Get currently active tid.
 */
function taxonomy_menu_block_find_active_tid($tree, $vid) {
  $active = NULL;

  // Check on what kind of page we are.
  $current = menu_get_item();

  // If we're on a NODE page.
  if ($current['path'] == 'node/%') {
    $term_reference_fields = array();

    // Load all defined fields.
    $fields = field_info_fields();

    // Loop over them and pull out the taxonomy term fields that are attached
    // to nodes.
    foreach ($fields as $key => $field) {
      if ($field['type'] == 'taxonomy_term_reference' && $field['deleted'] == '0' && isset($field['bundles']['node'])) {
        foreach ($field['bundles']['node'] as $bundle) {
          $term_reference_fields[$bundle][] = $key;
        }
      }
    }

    $node = $current['page_arguments'][0];

    // Check if the current node has a term reference field.
    if (isset($term_reference_fields[$node->type])) {
      foreach ($term_reference_fields[$node->type] as $term_reference_field) {
        $term_reference_field = $node->$term_reference_field;
        if (!empty($term_reference_field['und'])) {
          // Only the first value will be selected, also for fields that allow
          // multiple values. It doesn't make sense to have more than one
          // active trail/items in a menu.
          $tid = $term_reference_field['und'][0]['tid'];
          // Check if the term actually belongs to the vocabulary we need to
          // display (node can have more than one term reference field).
          if (isset($tree[$tid])) {
            $active = $tid;
          }
        }
      }
    }
  }

  // If we're on a TAXONOMY page.
  if ($current['path'] == 'taxonomy/term/%') {
    $tid = end($current['original_map']);
    // Check if the current tid is in our tree.
    if (isset($tid) && isset($tree[$tid])) {
      $active = $tid;
    }
  }

  return $active;
}

/**
 * Add active trail.
 *
 * Options:
 *  0 = not active. Has been set as default in taxonomy_menu_block_get_tree()
 *  1 = active trail
 *  2 = active
 */
function taxonomy_menu_block_add_active_trail($tree, $tid = NULL) {

  // If we have an active page, add the trail.
  if ($tid) {
    // Set current page as active.
    $tree[$tid]['active_trail'] = '2';
    // Add active trail to the parent(s).
    $parent = $tree[$tid]['parents'][0];
    for ($i = 0; $i < $tree[$tid]['depth']; $i++) {
      $tree[$parent]['active_trail'] = '1';
      $parent = $tree[$parent]['parents'][0];
    }
  }

  return $tree;
}

/**
 * Nest tree.
 */
function taxonomy_menu_block_nest_tree($tree, $root = '0') {
  $nested_tree = array();

  // Loop over the tree and search for direct children of the root.
  foreach ($tree as $tid => $term) {
    // Direct child is found.
    if ($term['parents'][0] == $root) {
      // Remove item from tree (we don't need to traverse this again).
      unset($tree[$tid]);
      // Append the child into result array and parse its children.
      $nested_tree[$tid] = $term;
      $nested_tree[$tid]['children'] = taxonomy_menu_block_nest_tree($tree, $tid);
    }
  }
  return $nested_tree;
}

/**
 * Generate markup for our list.
 */
function theme_taxonomy_menu_block($variables) {
  $tree = $variables['items'];
  $config = $variables['config'];

  $num_items = count($tree);
  $i = 0;

  $output = '<ul>';
  foreach ($tree as $tid => $term) {
    $i++;
    // Add classes.
    $attributes['class'] = array();
    $classes = '';
    if ($i == 1) {
      $attributes['class'][] = 'first';
    }
    if ($i == $num_items) {
      $attributes['class'][] = 'last';
    }
    if ($term['active_trail'] == '1') {
      $attributes['class'][] = 'active-trail';
    }
    if ($term['active_trail'] == '2') {
      $attributes['class'][] = 'active';
    }
    // If we have classes, flatten to a string.
    if (!empty($attributes['class'])) {
      $classes = drupal_attributes($attributes);
    }

    // Set alias option to true so we don't have to query for the alias every
    // time, as this is cached anyway.
    $output .= '<li' . $classes . '>' . l($term['name'], $term['path'], $options = array('alias' => TRUE));
    if (!empty($term['children'])) {
      $output .= theme_taxonomy_menu_block(array('items' => $term['children'], 'config' => $config));
    }
    $output .= '</li>';
  }
  $output .= '</ul>';

  return $output;
}
